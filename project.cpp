// Elisabetta Caldesi and Anthony DiFalco
// Asteroids Game

#include <iostream>
#include "gfxnew.h"
#include <cmath>
#include <unistd.h>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string>
#define DT 1
using namespace std;

// Functions prototypes
void drawShip(double, double, double, double, double, double); // function that draws the spaceship

void drawAsteroids(vector <double> &xastcenter, vector <double> &yastcenter, 
		vector <double> &radiusast,vector <double> &xvelocityast, 
		vector <double> &yvelocityast, vector <bool> &hit2); // function that draws asteroids

vector <bool> checkShot(vector<double> &xastcenter, vector <double> &yastcenter,
		 vector<double> &radiusast, vector <double> &xshot, vector <double> &yshot); // function that checks if the missile hit the asteroid

bool checkCollision(double,double, double, double, double, double,double,vector <bool> &hit, 
		vector <double> &xastcenter, vector <double> &yastcenter, vector <double> &radiusast); // function that checks for collisions between the asteroids and the spaceship

void circularLace(double, double, double); // function that draws the explosion of the spaceship




int main() {
	
	// declare and initialize variables
	
	int width, height;

	width= 1000;
	height= 800;

	gfx_open(width,height,"Asteroids");
	
	char c= ' ';
	int n;
	
	// variables used for the function checkShot
	double xshotvalue= 0;
	double yshotvalue= 0;

	double xshotvvalue= 0;
	double yshotvvalue= 0;

	vector <double> xshot;
	vector <double> yshot;

	vector <double> xshotv;
	vector <double> yshotv;
	
	double theta= 0;
	double phi= 0;

	double xv= 0;
	double yv= 0;

	
	// coordinates of the position of the space ship when the program begins
	double x1, y1, x2, y2, x3, y3;
	double xcenter, ycenter;
	int r= 40;
	
	xcenter= width/2;
	ycenter= height/2;
	
	x1= xcenter+ r*cos(M_PI/2);
	y1= ycenter+ r*sin(M_PI/2);

	x2= xcenter+ .5*r*cos(7*M_PI/6);
	y2= ycenter+ .5*r*sin(7*M_PI/6);

	x3= xcenter+ .5*r*cos(11*M_PI/6);
	y3= ycenter+ .5*r*sin(11*M_PI/6);

	// value initialized for the function checkCollision
	bool destroyship = false;
	
	// texts displayed in the menus
	const char *startText= "Welcome to Asteroids!";
	const char *startText1= "To turn right, press the right arrow key.";
	const char *startText2= "To turn left, press the left arrow key.";
	const char *startText3= "To accelerate, press the forward arrow key.";
	const char *startText4= "To pause, press the p key.";
	const char *startText5= "To shoot, press the spacebar.";
	const char *startText6= "Press s to start. Enjoy!.";
	

	const char *endText= "SORRY, GAME OVER.";
	const char *pauseText= "Do you want to quit? Y/N";
	
	// variables used for the function drawAsteroids, checkShot and checkCollision
	vector <double> xastcenter;
	vector <double> yastcenter;

	vector <double> xvelocityast;
	vector <double> yvelocityast;

	vector <double> radiusast;
		
	double radius, alpha, tmpx, tmpy, tempvx, tempvy;
	double generator;
	int counter= 0;

	vector <bool> hit;
	vector <bool> hit2;

	while (c != 's'){
		// start menu
		gfx_color(10,200,50);
		gfx_text(width/2-80, height/2, startText);
		gfx_text(width/2-80, height/2+15, startText1);
		gfx_text(width/2-80, height/2+30, startText2);
		gfx_text(width/2-80, height/2+45, startText3);
		gfx_text(width/2-80, height/2+60, startText4);
		gfx_text(width/2-80, height/2+75, startText5);
		gfx_text(width/2-80, height/2+90, startText6);

		gfx_flush();
		while(gfx_event_waiting()){
			gfx_wait();
		}
		c = gfx_wait();
	}
	gfx_clear();
	
	// draw spaceship
	drawShip(x1,y1,x2,y2,x3,y3);						

	
	while (c!='y' && !destroyship){
		// draw Asteroids in here 
		counter ++; 
		if (counter % 43 == 0) { // every time an asteroid appears
			hit2.push_back(false);
			generator= rand() %19 +1;
			alpha = generator *M_PI /10;

			tempvx= cos(alpha+M_PI); // randomly generated by the generator which makes alpha random
			tempvy= sin(alpha+M_PI); // same as above

			xvelocityast.push_back(tempvx);
			yvelocityast.push_back(tempvy);
		
			radius = rand() %7 +5; // randomly generated radius of asteroid
			radiusast.push_back(radius);
		
			// the asteroids are generated off the board
			// the if statements divide the board from corner to corner and identify where the asteroid should be generated

			if (alpha < 7*M_PI/4 && alpha > 5*M_PI/4){
				tmpx= rand() %7/8 *width + width/8;
				tmpy = height+20;
				xastcenter.push_back(tmpx);
				yastcenter.push_back(tmpy);
			}

			if (alpha > 3*M_PI/4 && alpha < 5*M_PI/4){
				tmpy= rand() %7/8 *height + height/8;
				tmpx = width+20;
				xastcenter.push_back(tmpx);
				yastcenter.push_back(tmpy);
			}

			if (alpha > 1*M_PI/4 && alpha < 3*M_PI/4){
				tmpx= rand() %7/8 *width + width/8;
				tmpy = -20;
				xastcenter.push_back(tmpx);
				yastcenter.push_back(tmpy);
			}

			if (alpha >0  && alpha < 1*M_PI/4){
				tmpy= rand() %7/8 *height + height/8;
				tmpx = -20;
				xastcenter.push_back(tmpx);
				yastcenter.push_back(tmpy);
			}

			if (alpha >7*M_PI/4 && alpha < 2*M_PI){
				tmpy= rand() %7/8 *height + height/8;
				tmpx = - 20;
				xastcenter.push_back(tmpx);
				yastcenter.push_back(tmpy);	
			}		

		}
		
		// brings the ship back to the window whenever it goes off
		if (xcenter < 0){
			xcenter = 1000;
		}
		if (xcenter > width){
			xcenter = 0;
		}
		if (ycenter < 0){
			ycenter = 800;
		}
		if (ycenter > 800){
			ycenter = 0;
		}	
		
		gfx_clear();
		
		drawAsteroids(xastcenter, yastcenter, radiusast, xvelocityast, yvelocityast, hit2);
		
		drawShip(x1,y1,x2,y2,x3,y3);
		
		// draws points where the missiles are supposed to be on the window
		for (int i=0; i< xshot.size(); i++){
			if (xshot[i]!=0 && yshot[i]!=0){
				gfx_point(xshot[i], yshot[i]);
			}
		}
		
		// here is where the user can determine the position of the ship by playing with it
		n= gfx_event_waiting();

		if (n!=0){
			c= gfx_wait();
		}
		if (n==1){ // when a key is pressed		
			// right arrow 
			if (c== 'S'){
				if (theta<2*M_PI){
					theta = theta + .2;
				} if (theta>=2*M_PI){
					theta = 0;
				}
			}
			// left arrow
			if (c== 'Q'){
				if (theta<2*M_PI){
					theta = theta - .2;
				} 
				if (theta>=2*M_PI){
					theta = 0;
				}
			}
			// forward arrow
			if (c== 'R'){
				xv = xv + cos(theta + M_PI/2);
				yv = yv + sin(theta + M_PI/2); 
			}
			// spacebar
			if (c== ' '){
				phi= theta;
				xshotvalue= xcenter+ r*cos(phi+ M_PI/2);
				yshotvalue= ycenter+ r*sin(phi+ M_PI/2);
				xshotvvalue= 10*cos(phi + M_PI/2);
				yshotvvalue= 10*sin(phi + M_PI/2);
				xshot.push_back(xshotvalue);
				yshot.push_back(yshotvalue);
				xshotv.push_back(xshotvvalue);
				yshotv.push_back(yshotvvalue);
			}
			// pause menu
			if (c=='p'){
				while (c != 'y' && c != 'n'){
					gfx_color(255,25,255);
					gfx_text(width/2-80, height/2, pauseText);
					while(gfx_event_waiting()){
						gfx_wait();
					}
					c = gfx_wait();
				}
			}
		}

		// updates position of xcenter and ycenter when the user pressed forward key
		xcenter= xcenter+ xv*DT;
		ycenter= ycenter+ yv*DT;

		// updates positions of the missiles 
		for (int i=0; i<xshot.size(); i++){
			xshot[i] = xshot[i] + xshotv[i]*DT;
			yshot[i] = yshot[i] + yshotv[i]*DT;
		}

		gfx_color(255,255,255);
		usleep(20000);
		gfx_flush();
		
		// position of the spaceship is updated after the user pressed a key
		x1= xcenter+ r*cos(M_PI/2+ theta);
		y1= ycenter+ r*sin(M_PI/2+ theta);

		x2= xcenter+ .5*r*cos(7*M_PI/6+ theta);
		y2= ycenter+ .5*r*sin(7*M_PI/6+ theta);

		x3= xcenter+ .5*r*cos(11*M_PI/6+ theta);
		y3= ycenter+ .5*r*sin(11*M_PI/6+ theta);
			
		
		if (xv > .1){
			xv = xv - .1;
		}
		if (xv < -.1){
			xv = xv + .1;
		}
		
		if (yv > .1){
			yv = yv - .1;
		} 
		if (yv < -.1){
			yv = yv + .1;
		}
	
                // vectors to check if the asteroid was hit
		vector <bool> ::iterator it2; // this vector that determines whether an asteroid should be drawn
                vector <bool> ::iterator it; // temporary vector return from the function checkShot
		it2 = hit2.begin();
		
		if (counter > 43){
			hit = checkShot(xastcenter,yastcenter,radiusast,xshot,yshot);
			for (it = hit.begin(); it!= hit.end(); it++){
				if (*it2==false && *it== true){
					*it2=true; // since this is true, the asteroid won't be redrawn
				}
				it2++;
			}		
			destroyship = checkCollision(theta, x1, y1, x2, y2, x3, y3,hit2, xastcenter, yastcenter, radiusast);
		}
		if(destroyship == true){
			// create explosion
			circularLace(x1,y1,20);
			circularLace(x2,y2,20);
			circularLace(x3,y3,20);
		}
	}
	gfx_clear();
	// display end text
	gfx_color(200,230,79);
	gfx_text(width/2 -40, height/2, endText);
	gfx_flush();
	usleep(1000000);


	return 0;
}

// function that draws a ship
void drawShip(double x1, double y1, double x2, double y2, double x3, double y3) {
	
	gfx_color(255, 255, 255);
	gfx_line(x1,y1,x2,y2);
	gfx_line(x2,y2,x3,y3);
	gfx_line(x1,y1,x3,y3);
	gfx_flush();

}

// function that draws the asteroids
void drawAsteroids(vector <double> &xastcenter, vector <double> &yastcenter, vector <double> &radiusast, vector <double> &xvelocityast, vector <double> &yvelocityast, vector <bool> &hit2){

	double x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;
	vector <double> ::iterator yit, xit, rit, vxit, vyit;
	vector <bool> ::iterator hit;

	yit= yastcenter.begin();
	vxit= xvelocityast.begin();
	vyit= yvelocityast.begin();
	rit= radiusast.begin();
	hit= hit2.begin();
	
	int height = 800;
	int width = 1000;

	for (xit = xastcenter.begin(); xit != xastcenter.end(); ++xit){
		// update positions of an asteroid that wasn't hit
		if (*hit==false){
			x1= *xit+ 5.6*(*rit)*cos(0);
			y1= *yit+ 5.6*(*rit)*sin(0);

			x2= *xit+ 6.3*(*rit)*cos(M_PI/7);
			y2= *yit+ 6.3*(*rit)*sin(M_PI/7);

			x3= *xit+ 3.7*(*rit)*cos(M_PI/3);
			y3= *yit+ 3.7*(*rit)*sin(M_PI/3);

			x4= *xit+ *rit*4.5*cos(M_PI/2);
			y4= *yit+ *rit*4.5*sin(M_PI/2);

			x5= *xit+ *rit*5*cos(5*M_PI/4);
			y5= *yit+ 5*(*rit)*sin(5*M_PI/4);

			x6= *xit+ *rit*4.8*cos(12*M_PI/7);
			y6= *yit+ *rit*4.8*sin(12*M_PI/7);
		
			// draw lines
			gfx_line(x1,y1,x2,y2);
			gfx_line(x2,y2,x3,y3);
			gfx_line(x3,y3,x4,y4);
			gfx_line(x4,y4,x5,y5);
			gfx_line(x5,y5,x6,y6);
			gfx_line(x1,y1,x6,y6);
			
			*xit= *xit + *vxit*(DT);
			*yit= *yit + *vyit*(DT);
		}	
		yit++;
		vxit++;
		vyit++;
		rit++;	
		hit++;


		// check bounds
		if (*xit < -10){
			*xit = width + 5;
		}
		if (*xit > width + 10){
			*xit = - 5;
		}

		if (*yit < -10){
			*yit = height + 5;
		}
		if (*yit > height + 10){
			*yit = -5;
		}
	}
}

// function that returns a boolean vector of the shots that hit any of the asteroids
vector <bool> checkShot(vector<double> &xastcenter, vector <double> &yastcenter,
		 vector<double> &radiusast, vector <double> &xshot, vector <double> &yshot){
	
	vector <bool> hit;
	vector <double>::iterator xit, yit, rit;
	xit = xastcenter.begin();
	yit = yastcenter.begin();
	rit = radiusast.begin();

        vector <double> tmpx;
	vector <double> tmpy;
	double rads;
        double tmpr;
	bool flag;

	while (xit!=xastcenter.end()){	
		// creates an ideal circumference around every asteroid and check if any of the points on it have been hit
		flag = false;
		tmpr = 10;		
		if (tmpx.empty() && tmpy.empty()){
			while (tmpr > 1){
				if (tmpr == 10){
					for (int i = 1; i < 150; i++){
						rads = i*M_PI/75;	
						tmpx.push_back(*xit+ 6*(*rit)*cos(rads));
						tmpy.push_back(*yit+ 6*(*rit)*sin(rads));
					}
					tmpr = 6*(*rit) * .8;
				}

				if (tmpr != 10){
					for (int j = 1; j < 150; j++){
						rads = j*M_PI/75;	
						tmpx.push_back(*xit+ (tmpr)*cos(rads));
						tmpy.push_back(*yit+ (tmpr)*sin(rads));
					}
					tmpr = tmpr*.8;
				}
			}
		}
		// here we check if the shots hit any of the points on that circumference	
		for (int i=0; i< xshot.size(); i++){
			double xs= xshot[i];
			double ys= yshot[i];
			for (int j=0; j<tmpx.size(); j++){
				double x= tmpx[j];
				double y= tmpy[j];
				if ((int)x== (int)xs && (int)y==(int)ys){
					flag= true;
				}
			}
		}	
		xit++;
		yit++;
		rit++;
		hit.push_back(flag); // here's where we insert values into hit
		tmpx.clear();
		tmpy.clear();
	}
	return hit;	
}

// this function returns a boolean value when an asteroid collides with the ship
bool checkCollision(double phi,double xo1, double yo1, double xo2, double yo2, double xo3, double yo3,vector <bool> &hitvect, vector <double> &xastcenter, vector <double> &yastcenter, vector <double> &radiusast){
	
	bool destroyship = false;
	vector <double>::iterator xit, yit, rit;
	vector <bool>::iterator hit;
	xit = xastcenter.begin();
	yit = yastcenter.begin();
	rit = radiusast.begin();
	hit = hitvect.begin();

        vector <double> tmpx;
	vector <double> tmpy;

        double tmpr;
	bool flag = false;
	double theta, rads;
	double r= 15;
	
	// creates three circles inside of the ship that will be used to check for the collisions
	vector <double> circle1x;
	vector <double> circle1y;
	vector <double> circle2x;
	vector <double> circle2y;
	vector <double> circle3x;
	vector <double> circle3y;

	// creates positions of the center of the 3 circles
	double x1= xo1 - .5*r*cos(M_PI/2+ phi);
	double y1= yo1- .5*r*sin(M_PI/2+ phi);
	
	double x2= xo2- .25*r*cos(7*M_PI/6+ phi);
	double y2= yo2- .25*r*sin(7*M_PI/6+ phi);

	double x3= xo3- .25*r*cos(11*M_PI/6+ phi);
	double y3= yo3- .25*r*sin(11*M_PI/6+ phi);

	// push back the values above into the 6 vectors corresponding to the coordinates of the 3 circles
	for (int i=0; i<360; i++){ 
		theta= i*M_PI/180;
		circle1x.push_back(x1 + r*cos(theta));
		circle1y.push_back(y1 + r*sin(theta));
		circle2x.push_back(x2 + r*cos(theta));
		circle2y.push_back(y2 + r*sin(theta));
		circle3x.push_back(x3 + r*cos(theta));
		circle3y.push_back(y3 + r*sin(theta));
	
	}

	while (xit!=xastcenter.end()){	
		// creates an ideal circumference around every asteroid and check if any of the points on it have been hit
		tmpr = 10;		
		if (tmpx.empty() && tmpy.empty()){
			while (tmpr > 1){
				if (tmpr == 10){
					for (int i = 1; i <150; i++){
						rads = i*M_PI/75;	
						tmpx.push_back(*xit+ 6*(*rit)*cos(rads));
						tmpy.push_back(*yit+ 6*(*rit)*sin(rads));
					}
					tmpr = 6*(*rit) * .8;
				}

				if (tmpr != 10){
					for (int j = 1; j < 150; j++){
						rads = j*M_PI/75;	
						tmpx.push_back(*xit+ (tmpr)*cos(rads));
						tmpy.push_back(*yit+ (tmpr)*sin(rads));
					}
					tmpr = tmpr*.8;
				}
			}
		}
		// if the asteroid was not hit with a missile, then it checks if the asteroid and the sip collided		
		if (*hit != true){
			for (int j=0; j<tmpx.size(); j++){
				double x= tmpx[j];
				double y= tmpy[j];
				for (int i=0; i<circle1x.size(); i++){
					double c1x= circle1x[i];
					double c1y= circle1y[i];
					double c2x= circle2x[i];
					double c2y= circle2y[i];
					double c3x= circle3x[i];
					double c3y= circle3y[i];
					if ((int)x== (int)c1x && (int)y==(int)c1y){
						flag= true;
					}
					if ((int)x== (int)c2x && (int)y==(int)c2y){
						flag= true;
					}
					if ((int)x== (int)c3x && (int)y==(int)c3y){
						flag= true;
					}
				}
			}	
		}
		xit++;
		yit++;
		rit++;
		hit++;
		tmpx.clear();
		tmpy.clear();
	}

	// if true, collision happened
	destroyship = flag;
	return destroyship;
	
}

// function that draws the explosion
void circularLace (double x, double y, double length) {

	// Base case
	if (length < 2) return;
	double theta = 0;

	gfx_color(247,131,14);
	
	// Draw Circle
	gfx_circle(x,y,length);              

	// Recursive calls	
	circularLace(length*cos(theta)+x,length*sin(theta)+y,length/3);

	theta = theta + M_PI/3;
        circularLace(length*cos(theta)+x,length*sin(theta)+y,length/3);

        theta = theta + M_PI/3;
        circularLace(length*cos(theta)+x,length*sin(theta)+y,length/3);

        theta = theta + M_PI/3; 
	circularLace(length*cos(theta)+x,length*sin(theta)+y,length/3);

        theta = theta + M_PI/3; 
	circularLace(length*cos(theta)+x,length*sin(theta)+y,length/3);

        theta = theta + M_PI/3; 
	circularLace(length*cos(theta)+x,length*sin(theta)+y,length/3);

        length = length/3;
}

